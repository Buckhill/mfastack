# Using MFAStack

MFAStack is intended to be integrated with various application. 

We provide a web-based administration interface for quick-access to certain functions of the server, as well as CLI interface for managing various features.

### Brief terminology overview

- `Identity` - information in the database about the device that generates OTPs. MFAStack shares their primary key with integrating applications.
- `KSM` - key storage module, the relational database that we save data to.
- `Administrator` - an account in `KSM` that makes certain `Identities` of higher privilege. These are used when you want to create / delete / update `Identities` and they serve as administrative authentication method.

# Interactive REST API documentation

MFAStack REST API is documented using [Swagger](http://swagger.io). 
Every MFAStack installation comes with interactive REST API documentation, and you can access it for the full API overview at: 

https://your.mfastack.domain/api 

(note: it's the real, working API so you will be making changes to your data by using it)

# Terminology and brief usage overview

MFAStack saves sensitive information to the database which it uses later to verify OTPs.
The information saved about a particular device is called an `Identity`. An example of an `Identity` would be information about Yubikey device when used in `Yubico OTP` mode.
For MFAStack to properly verify an OTP generated by Yubikey, it needs to have access to Yubikey's `Public Identity`, `Private Identity`, `Secret key` and `counter` information.

When all the info is present, MFAStack is able to pull the OTP through the algorithm that verifies its validity. It saves the mentioned information into the database which we call Key Storage Module or `KSM`.
The information saved is referred to as an `Identity`. 

Once an `Identity` is created, MFAStack returns its numeric ID. The application which integrates with MFAStack **must** save this numeric identity (to a database or anywhere else where it has access to it).

To verify an OTP generated by a device, the application must provide the numeric `ID` and the otp generated by the device. 
If the OTP is valid, MFAStack returns HTTP status code 200. If not, it returns HTTP status code 400. The exact error is logged to MFAStack's server log so that no information about the key is accidentally revealed.

An example of REST call using `cURL` to verify OTP 123456 for Identity ID: 1 would be: 

```bash
$ curl -i -X GET https://your.mfastack.domain/v1/verify/1/123456
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Server: A web server
Cache-Control: no-cache
Date: Thu, 4 Jun 2015 13:29:54 GMT
```

## The authentication workflow using 2nd factor 

The classic auth/login mechanism flows like this:

- User arrives at the protected page and is asked for username / password 
- User fills in the username and password and submits the data
- Server matches the user-provided credentials against its database and if successful, user is logged in and remembered via cookies / sessions

The multi-factor authentication using MFAStack flows like this:

- User arrives at the protected page and is asked for username / password and for an OTP (one time password)
- User fills in the form and submits the data
- Server matches the provided credentials, and if correct - it also retrieves a list of identities from the fore-mentioned junction table
- Your code goes through the records and it performs a POST request to MFAStack providing the `identity_id` and `OTP` that user entered
- If MFAStack replies with HTTP status code 200, the OTP was valid. One user can have multiple Identities associated with their account, so you can perform this verification step in a loop.
- Upon success, your user system issues cookies / starts sessions and your user is authenticated, without any further modifications to the code.

# Integration code examples

To integrate MFAStack with any application, you have to alter your user-system slightly by creating an additional table which connects users to MFAStack's identities. 

An example using MySQL would be:

```sql
CREATE TABLE users2mfastack (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    user_id INT UNSIGNED NOT NULL,
    identity_id INT UNSIGNED NOT NULL,
    PRIMARY KEY(id)
) ENGINE=InnoDB;
```

The next part is describing authentication using an OTP generated by a supported devce, eg. Yubikey:

### The HTML form
<hr>
```html
<form method="POST" action="/authenticate">
    <label for="username">Your username: </label>
    <input type="text" name="username" id="username" />
    
    <label for="password">Password: </label>
    <input type="password" name="password" id="password" />
    
    <label for="otp">One time password: </label>
    <input type="password" name="otp" id="otp" />
</form>
```

### PHP code processing the authentication

We will illustrate this step using PHP code and [Guzzle](https://github.com/guzzle/guzzle) library for performing an HTTP request towards MFAStack.

```php

$username = $_POST['username'];
$password = $_POST['password'];
$otp = $_POST['otp'];

$authenticated = your_auth_function($username, $password);

// We'll assume that you are able to verify username and password and the following code displays how to perform the MFAStack integration using Guzzle
if($authenticated)
{
    // At this point, you should retrieve the identity_id from the database. 
    // We'll assume that we have user ID stored in $user_id variable and that we have a PDO connection available
    $dsn = 'mysql:dbname=testdb;host=127.0.0.1';
    $dbuser = 'dbuser';
    $dbpassword = 'dbpass';
    
    try
    {
        $pdo = new PDO($dsn, $dbuser, $dbpassword);
        
        $stmt = $pdo->prepare("SELECT identity_id FROM users2mfastack WHERE user_id = :user_id");
        
        $stmt->bindValue(':user_id', $user_id, PDO::PARAM_INT);
        
        $stmt->execute();
        
        $identities = $stmt->fetchAll(PDO::FETCH_ASSOC);
        
        $client = new GuzzleHttp\Client();

        $mfa_auth = false;
        
        foreach($identities as $record)
        {
            // The URL where the request should be sent is the domain where MFAStack is (can be an IP) and the resource is /v1/verify/{identity_id}/{otp}
            // To better illustrate the resource, if we put identity_id in there and OTP that's 123456 then we get https://your.mfastack.domain/v1/verify/1/123456
            $result = $client->post(sprintf("https://your.mfastack.domain/v1/verify/%s/%s", $record['identity_id'], $otp));
            
            if($result->getStatusCode() == 200)
            {
                $mfa_auth = true; 
                
                break; // stop checking other identities, we got 200 back so we've verified the OTP 
            }
        }
        
        if($mfa_auth)
        {
            // Set the cookie, initiate server-side session and bootstrap your application here.
            // Ideally, you might want to make this whole process as a function or a simple class
        }
    }
    catch(\Exception $e)
    {
        echo "We're sorry, but an error occurred. Message: ". $e->getMessage();
    }
}
```


## An example using Node.js 

For this example, we'll use [Request HTTP client](https://github.com/request/request) for Node.js

We will also assume that you verified the user and that you have a list of associated identities in an object

```javascript

var associated_identities = [{"identity_id": 1}, {"identity_id": 2}, {"identity_id": 3}];
var otp = '12345'; // This should be read from user input

var request = require('request');

var i;

for(i = 0; i < associated_identities.length; i++)
{
    request.post("https://your.mfastack.doma/v1/verify/" + associated_identities[i].identity_id + "/" + otp, function(err, httpResponse, body) {
        // Checking for HTTP 200 in the closure means that OTP verification is successful
    });
}

```